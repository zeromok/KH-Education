-- sample1.sql


-- ******************************************************
-- SELECT 문의 기본구조와 각 절의 실행순서
-- ******************************************************
--  - Clauses -                 - 실행순서 -
--
-- SELECT clause                    (5)
-- FROM clause                      (1)
-- WHERE clause                     (2)
-- GROUP BY clause                  (3)
-- HAVING clause                    (4)
-- ORDER BY clause                  (6)
-- ******************************************************


-- ------------------------------------------------------
-- 1. 단일(행) (반환)함수
-- ------------------------------------------------------
-- 단일(행) (반환)함수의 구분:
--
--  (1) 문자 (처리)함수 : 문자와 관련된 특별한 조작을 위한 함수
--      a. INITCAP  - 첫글자만 대문자로 변경
--      b. UPPER    - 모든 글자를 대문자로 변경 
--      c. LOWER    - 모든 글자를 소문자로 변경
--      d. CONCAT   - 두 문자열 연결
--      e. LENGTH   - 문자열의 길이 반환
--      f. INSTR    - 문자열에서, 특정 문자열의 위치(인덱스) 반환
--      g. SUBSTR   - 문자열에서, 부분문자열(substring) 반환
--      h. REPLACE  - 문자열 치환(replace)
--      i. LPAD     - 문자열 오른쪽 정렬 후, 왼쪽의 빈 공간에 지정문자 채우기(padding)
--      j. RPAD     - 문자열 왼쪽 정렬 후, 오른쪽의 빈 공간에 지정문자 채우기(padding)
--      k. LTRIM    - 문자열의 왼쪽에서, 지정문자 삭제(trim)
--      l. RTRIM    - 문자열의 오른쪽에서, 지정문자 삭제(trim)
--      m. TRIM     - 문자열의 왼쪽/오른쪽/양쪽에서, 지정문자 삭제(trim)
--                    (단, 문자열의 중간은 처리못함)
--  (2) 숫자 (처리)함수 : 
--  (3) 날짜 (처리)함수
--  (4) 변환 (처리)함수
--  (5) 일반 (처리)함수
--
--  단일(행) (반환)함수는, 테이블의 행 단위로 처리됨!
-- ------------------------------------------------------

-- ------------------------------------------------------
-- (1) 문자(처리) 함수 - INITCAP
-- ------------------------------------------------------
--     첫글자만 대문자로 변경
-- ------------------------------------------------------
SELECT
   'ORACLE SQL',
   initcap('ORACLE SQL') -- 각 단어마다 첫문자->대문자로... like 카멜기법
FROM
   dual;
   -- 테이블은 없지만 FROM은 생략 불가능 이므로 dual을 써서 더미테이블을 만들어준다.


SELECT
   email,
   initcap(email)
FROM
   employees;


-- ------------------------------------------------------
-- (2) 문자(처리) 함수 - UPPER
-- ------------------------------------------------------
--     모든 글자를 대문자로 변경
-- ------------------------------------------------------
SELECT
   'Oracle Sql',
   upper('Oracle Sql')
FROM
   dual;


SELECT
   last_name,
   upper(last_name)
FROM
   employees;


SELECT
   last_name,
   salary
FROM
   employees
 --WHERE
    --upper(last_name) = 'KING';    -- *Decommendation*  : The index with the column cannot be used.(비추천)
WHERE
   last_name = initcap('KING');  -- *Recommendation*  : The index with the column can be used.

  


-- ------------------------------------------------------
-- (3) 문자(처리) 함수 - LOWER
-- ------------------------------------------------------
--     모든 글자를 소문자로 변경
-- ------------------------------------------------------
SELECT
   'Oracle Sql',
   lower('Oracle Sql')
FROM
   dual;


SELECT
   last_name,
   lower(last_name)
FROM
   employees;


-- ------------------------------------------------------
-- (4) 문자(처리) 함수 - CONCAT
-- ------------------------------------------------------
--     두 문자열 연결(Concatenation)
--     연결방법 2가지 : ||, concat()
-- ------------------------------------------------------
-- SELECT
--    -- || (Concatenation Operator) == concat function
--    'Oracle' || 'Sql',
--    concat('Oracle', 'Sql')
SELECT
   -- || (Concatenation Operator) == concat function
   'Oracle' || 'Sql' || 'third', 
   concat( concat('Oracle', 'Sql'), 'third')
FROM
   dual;

-- 연결 방법에는 2가지 방법이 있다.
-- || 로 연결하는 방법과 concat으로 연결하는 방법
-- concat는 2문자 연결이므로 그 이상 연결하려면 중복으로 써서 연결을 시켜준다.



SELECT
   -- || (Concatenation Operator) == concat function
   last_name || salary,
   concat(last_name, salary)
FROM
   employees;


SELECT
   -- || (Concatenation Operator) == concat function
   last_name || hire_date,
   concat(last_name, hire_date)
   -- date타입도 연결 가능하다.
FROM
   employees;


-- ------------------------------------------------------
-- (5) 문자(처리) 함수 - LENGTH
-- ------------------------------------------------------
--     문자열의 길이 반환
-- ------------------------------------------------------
--  A. LENGTH   returns Characters
--  B. LENGTHB  returns Bytes : 문자열의 데이터 크기반환
-- ------------------------------------------------------
SELECT
   'Oracle',
   length('Oracle')
FROM
   dual;


SELECT
   last_name,
   length(last_name)
FROM
   employees;


-- '한글' 문자열을 유니코드(Unicode)로 표현하면, '\D55C\AE00' 임.
SELECT
    '한글',
    length('한글')   AS length,
    lengthb('한글')  AS lengthb
FROM
   dual;


SELECT
    unistr('\D55C\AE00'),
    length( unistr('\D55C\AE00') )    AS length,
    lengthb( unistr('\D55C\AE00') )   AS lengthb
FROM
   dual;


-- ------------------------------------------------------
-- (6) 문자(처리) 함수 - INSTR
-- ------------------------------------------------------
--     문자열에서, 특정 문자열의 (시작)위치(시작 인덱스) 반환
--    instr('문자열', '찾을 문자', 몇번째인덱스부터?, 중복되어있으면 몆번째 인덱스 반환해줄까?)
-- ------------------------------------------------------
-- 주의) Oracle 의 인덱스 번호는 1부터 시작함!!!
-- ------------------------------------------------------
SELECT
   instr('MILLER', 'L', 1, 2),   -- 1: offset, 2: occurence
   -- 2의 뜻 : 내가 찾는 문자가 중복되어있으면 2번째 나온 문자의 인덱스를 반환하라.

   instr('MILLER', 'X', 1, 2)    -- 1: offset, 2: occurence
FROM
   dual;


-- ------------------------------------------------------
-- (7) 문자(처리) 함수 - SUBSTR
-- ------------------------------------------------------
--     문자열에서, 부분문자열(substring) 반환
--    substr('문자열', 몇번째 인덱스부터 시작할까?, 몇번째 인덱스까지 반환할까?)
--    뒷 숫자 하나만 올 경우 그 이후 자리 반환시켜준다.
-- ------------------------------------------------------
-- 주의) Oracle 의 인덱스 번호는 1부터 시작함!!!
-- ------------------------------------------------------
SELECT
    --substr('123456-1234567', 1, 6)
    --substr('123456-1234567', 8)
    -- 8번째 자리부터 그 이후자리 반환
    substr('123456-1234567', 1, 7) || '*******' as "주민등록번호"
    -- 첫번째 자리부터 7번째자리까지 반환
FROM
   dual;

-- In the Oracle SQL*Developer
-- SELECT
--    hire_date AS 입사일,
--    substr(hire_date, 1, 2) AS 입사년도

-- In the Visual Source Code
SELECT
   hire_date,
   to_char(hire_date) AS 입사일,
   to_char(hire_date, 'RR/MM/DD') AS 일사일2,
   -- 값은 같지만 문자열 타입으로 뽑아낸다.
   substr( to_char(hire_date), 8, 2 ) AS 입사년도
FROM
   employees;

-- 주민등록번호 중 뒷부분만 뽑아내보자
SELECT
   '900303-1234567',
   substr('900303-1234567', 8)
   -- 8 = offset index
FROM
   dual;


-- 그런데, offset index를 음수를 사용할 수 있다면????
-- - 가 붙으면 문자열의 끝부터 시작하는 offset index
SELECT
   '900303-1234567',
   substr('900303-1234567', -7)
FROM
   dual;


-- ------------------------------------------------------
-- (8) 문자(처리) 함수 - REPLACE
-- ------------------------------------------------------
--     문자열 치환(replace)
--    replace('문자열', '이 문자를', '이 문자로 치환')
-- ------------------------------------------------------
SELECT
   replace('JACK and JUE', 'J', 'BL')
   -- J를 BL로 치환
FROM
   dual;


-- ------------------------------------------------------
-- (9) 문자(처리) 함수 - LPAD
--    lpad('문자열', 총문자열지정, '남은 문자열을 이거로 채워라')
-- ------------------------------------------------------
--      문자열 오른쪽 정렬 후, 
--      왼쪽의 빈 공간에 지정문자 채우기(padding)
-- ------------------------------------------------------
SELECT
   lpad('MILLER', 10, '*')
   -- 총 문자열 : 10, 남은문자열은 * 로 채워라
FROM
   dual;


-- ------------------------------------------------------
-- (10) 문자(처리) 함수 - RPAD
-- ------------------------------------------------------
--      문자열 왼쪽 정렬 후, 
--      오른쪽의 빈 공간에 지정문자 채우기(padding)
-- ------------------------------------------------------
SELECT
   rpad('MILLER', 10, '*')
FROM
   dual;


SELECT
   substr('900303-1234567', 1, 8) || '******' AS 주민번호
FROM
   dual;


SELECT
   rpad(
      substr('900303-1234567', 1, 8), 14, '*'
   ) AS 주민번호
FROM
   dual;


-- ------------------------------------------------------
-- (11) 문자(처리) 함수 - LTRIM
--    ltrim('문자열', '지정할 문자')
--    두개의 문자열을 지정(M,I)하면 각각 삭제하라는 의미
-- ------------------------------------------------------
--    문자열의 왼쪽에서, 지정문자 삭제(trim)
-- ------------------------------------------------------
SELECT
   ltrim('MMMIMLLER', 'M'),
   -- 지정한 문자를 나타나지 않을때 까지 삭제
   ltrim('MMMIMLLER', 'MI')
   -- 두개의 문자열을 지정(M,I)하면 각각 삭제하라는 의미
   -- NOT MI / M,I 따로따로 봐야한다.
FROM
   dual;


-- 공백이 들어있을 때
-- 삭제할 문자열을 지정하지 않으면 디폴트로 공백을 제거한다.
-- 대신 오른쪽 공백은 그대로다 그래서 length는 7이 나온다.
SELECT
   ltrim(' MILLER '),
   length( ltrim(' MILLER ') )
FROM
   dual;


-- ------------------------------------------------------
-- (12) 문자(처리) 함수 - RTRIM
--    rtrim('문자열', '지정할 문자')
--    삭제 할 문자를 지정하지 않으면 디폴트로 공백제거
-- ------------------------------------------------------
--    문자열의 오른쪽에서, 지정문자 삭제(trim)
-- ------------------------------------------------------
SELECT
   rtrim('MILLRER', 'R')
FROM
   dual;


SELECT
   rtrim(' MILLER '),
   length( rtrim(' MILLER ') )
FROM
   dual;


-- ------------------------------------------------------
-- (13) 문자(처리) 함수 - TRIM
-- ------------------------------------------------------
--    문자열의 왼쪽/오른쪽/양쪽에서, 지정문자 삭제(trim)
--    (단, 문자열의 중간은 처리못함)
-- ------------------------------------------------------
-- 문법)
--    TRIM( LEADING 'str' FROM 컬럼명|표현식 )
--    TRIM( TRAILING 'str' FROM 컬럼명|표현식 )
--    TRIM( BOTH 'str' FROM 컬럼명|표현식 )
--    TRIM( 'str' FROM 컬럼명|표현식 )     -- BOTH (default)
-- ------------------------------------------------------
SELECT
   trim( '0' FROM '0001234567000' )             -- default: BOTH (양쪽에서 제거)
FROM
   dual;


SELECT
   trim( LEADING '0' FROM '0001234567000' )     -- 문자열 왼쪽에서 제거
FROM
   dual;


SELECT
   trim( TRAILING '0' FROM '0001234567000' )    -- 문자열 오른쪽에서 제거
FROM
   dual;

