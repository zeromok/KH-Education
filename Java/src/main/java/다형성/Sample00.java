package Java.src.main.java.다형성;

public class Sample00 {

    // ==============================
    // 다형성 (Polymorphism) 이란 ?
    // ==============================
    /*
        하나의 객체가 여러가지 타입을 가질 수 있는 것을 의미 합니다.
        자바에서는 이러한 다형성을 부모클래스 타입의 참조 변수로 자식클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현
        다형성은 상속, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나 입니다.
        - 같은 타입이지만 실행 결과가 다양한 객체 대입(이용) 가능한 성질
        - 부모타입에는 모든 자식객체가 대입 가능
        - 자식타입은 부모타입으로 자동 타입변환
        : 부모클래스 변수 = 자식클래스타입; -> 자동타입변환
        : 바로위 부모가 아니더라도 상속계층의 상위면 자동타입변환 가능
        예) 자동차는 타이어 타입으로 한국타이어와 금호타이어를 사용하지만 각 타이어의 성능은 다름 (다형성)
    */

    // ==================
    // 참조변수의 다형성
    // ==================
    /*
        class Parent{...}
        class Child extends Parent { ... }
        ...
        Parent pa = new Parent(); // 허용

        Child ch = new Child();   // 허용

        Parent pc = new Child();  // 허용

        Child cp = new Parent();  // 오류 발생

        특정타입의 참조변수로는 당연히 같은 타입의 인스턴스를 참조할 수 있다.
        : 참조변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 때문에

        부모클래스 타입의 참조변수로도 자식클래스 타입의 인스턴스를 참조할 수 있다.
        : 참조변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 적기 때문에

        자식클래스 타입의 참조변수로는 부모클래스 타입의 인스턴스를 참조할 수 없다.
        : 참조변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 때문이다.
    */
    // 클래스는 상속을 통해 확장될 수 있어도 축소될 수는 없으므로, 자식클래스에서 사용할 수 있는 멤버의 개수가
    // 언제나 부모클래스와 같거나 많게 됩니다.

    // ======================
    // 참조 변수의 타입 변환
    // ======================
    /*
        자바에서는 참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있습니다.
        1. 서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있습니다.
        2. 자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략할 수 있습니다.
        3. 하지만 부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 합니다.

        // 예제
        class Parent { ... }
        class Child extends Parent { ... }
        class Brother extends Parent { ... }
        ...
        Parent pa01 = null;
        Child ch = new Child();
        Parent pa02 = new Parent();
        Brother br = null;

        pa01 = ch;          // pa01 = (Parent)ch; 와 같으며, 타입 변환을 생략할 수 있음.
        br = (Brother)pa02; // 타입 변환을 생략할 수 없음.
        br = (Brother)ch;   // 직접적인 상속 관계가 아니므로, 오류 발생.
    */

    // =================
    // instanceof 연산자
    // =================
    /*
        다형성으로 인해 런타임에 참조변수가 실제로 참조하고 있는 인스턴스의 타입을 확인할 필요성이 생깁니다.
        자바에서는 instanceof 연산자를 제공하여, 참조변수가 참조하고 있는 인스턴스의 실제타입을 확인할 수 있도록 해줌
    */

    // =========================
    // instanceof 연산자의 문법
    // =========================
    /*
        참조변수 instanceof 클래스이름

        왼쪽에 전달된 참조변수가 실제로 참조하고 있는 인스턴스의 타입이 오른쪽에 전달된 클래스타입 이면
        true 를 반환하고, 아니면 false 를 반환합니다.
        만약에 참조변수가 null 을 가르키고 있으면 false 를 반환합니다.
    */
    // 예제
    /*
    class Parent { }
    class Child extends Parent { }
    class Brother extends Parent { }



    public class Polymorphism01 {
         public static void main(String[] args) {

             Parent p = new Parent();

            System.out.println(p instanceof Object); // true
            System.out.println(p instanceof Parent); // true
            System.out.println(p instanceof Child);  // false
            System.out.println();

            Parent c = new Child();

            System.out.println(c instanceof Object); // true
            System.out.println(c instanceof Parent); // true
            System.out.println(c instanceof Child);  // true

    }

}
    */

    // ===============================
    // 추상클래스
    // 추상 메소드(Abstract Method)
    // ===============================
    /*
        추상메소드란 자식클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미한다.
        자바에서 추상메소드를 선언하여 사용하는 목적은 추상메소드가 포함된 클래스를 상속받는 자식클래스가 반드시 추상메소드를 구현하도록 하기위해

        예를들면 모듈처럼 중복되는 부분이나 공통적인 부분은 미리 다 만들어진 것을 사용하고, 이를 받아 사용하는 쪽에서는
        자신에서 필요한 부분만을 재정의하여 사용함으로써 생산성이 향상되고 배포 등이 쉬어지기 때문에

        이러한 추상메소드는 선언부만이 존재하며, 구현부는 작성되어 있지 않다.
        작성되어있지 않은 구현부를 자식클래스에서 오버라이딩하여 사용하는 것
    */



    // ================================
    // 다형성 - 전제조건은 "상속" 이다.
    // ================================
    /*
        동물 - sound() method

          강아지           고양이
        @Override       @Override
        sound(){}       sound(){}
    */

}// end class
